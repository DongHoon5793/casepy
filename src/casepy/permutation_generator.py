from .simple_methods import *
from .utils import *
import random


class PermutationGenerator:
    """
    PermutationGenerator is designed to generates all possible permutations of elements in a list with a given number of selections.
    The permuation is generated by a given iterator number and it is the n-th permutation of the all possible permutations.
    As default, the n-th permutation is generated by the lexicographic order.
    But, if the priority of the elements is given, the permutation is generated by the given priority.

    The elements can be duplicated in the list.

    .. _permutationgenerator:

    """

    def __init__(self):
        """
        Initialize the PermutationGenerator.
        """
        self.element_list_initialized = False
        self.number_of_selection_initialized = False
        self.must_have_elements = False

    def set_parameters(self, element_list: list, in_number_of_selection: int):
        """
        Initialize the PermutationGenerator with the given number of selections and the element list.

        Args:
            in_number_of_selection (int): The number of selections.
            element_list (list): The list of elements.
        """
        self.in_number_of_selection = in_number_of_selection
        self.element_list = sorted(element_list)

        self.element_list_initialized = True
        self.number_of_selection_initialized = True
        self.max_possible = self.__duplicated_case_recursive(
            in_list_to_bin(self.element_list)[0], self.in_number_of_selection
        )

    # def set_must_have_elements(self, in_elements_list: list):
    #     if len(in_elements_list) == len(self.element_list):
    #         # TODO: [A, "", E, D, ""] -> replace elements in ""
    #         pass
    #     else:
    #         self.must_have_elements = True
    #         self.must_have_list = in_elements_list
    #         for element in in_elements_list:
    #             self.element_list.remove(element)

    #         self.in_number_of_selection -= len(in_elements_list)
    #         self.max_possible = permutation(
    #             len(self.element_list), self.in_number_of_selection
    #         ) * (self.in_number_of_selection + 1)

    def __duplicated_case_recursive(self, in_list: list, in_number_of_select: int):
        """
        Recursive function to calculate all possible number of permutation cases.

        Args:
            in_list (list): The list of elements.
            in_number_of_select (int): The number of selections.

        Returns:
            int: The number of all possible cases.
        """
        if sum(in_list) == 1:
            return 1

        result_sum = 0
        if in_number_of_select == 1:
            for i in in_list:
                if i != 0:
                    result_sum += 1
            return result_sum
        for i in range(len(in_list)):
            if in_list[i] != 0:
                result_sum += self.__duplicated_case_recursive(
                    in_list[:i] + [in_list[i] - 1] + in_list[i + 1 :],
                    in_number_of_select - 1,
                )
        return result_sum

    def possible_cases(self):
        """
        Return the number of all possible cases.

        Returns:
            int: The number of all possible cases.
        """
        return self.max_possible

    def __next_permutation(self, in_list: list):
        """
        Return the next permutation of the list.

        Args:
            in_list (list): The list of elements.

        Returns:
            list: The next permutation of the list.
        """
        if in_list is None or len(in_list) == 0:
            return None

        left_elements = self.element_list.copy()
        for i in in_list:
            left_elements.remove(i)

        for i in range(self.in_number_of_selection - 2, -1, -1):
            if in_list[i] < in_list[i + 1]:
                target_k = i
                break
        else:
            return

        target_l = 0
        for i in range(self.in_number_of_selection - 1, -1, -1):
            if in_list[target_k] < in_list[i]:
                target_l = i
                break

        in_list[target_k], in_list[target_l] = in_list[target_l], in_list[target_k]

        test = in_list[target_k + 1 :]
        test.reverse()

        return in_list[: target_k + 1] + test

    def __next_permutation_partial(self, in_list: list):
        head, tail = (
            self.element_list[: self.in_number_of_selection],
            self.element_list[self.in_number_of_selection :],
        )
        head = in_list
        tail = self.element_list.copy()
        for i in in_list:
            tail.remove(i)
        # print("Mine = ", head, tail)
        right_head_indexes = range(self.in_number_of_selection - 1, -1, -1)
        left_tail_indexes = range(len(tail))

        while True:

            # Starting from the right, find the first index of the head with
            # value smaller than the maximum value of the tail - call it i.
            pivot = tail[-1]
            for i in range(self.in_number_of_selection - 1, -1, -1):
                if head[i] < pivot:
                    break
                pivot = head[i]
            else:
                return
            # Starting from the left, find the first value of the tail
            # with a value greater than head[i] and swap.
            for j in left_tail_indexes:
                if tail[j] > head[i]:
                    head[i], tail[j] = tail[j], head[i]
                    break
            # If we didn't find one, start from the right and find the first
            # index of the head with a value greater than head[i] and swap.
            else:
                for j in right_head_indexes:
                    if head[j] > head[i]:
                        head[i], head[j] = head[j], head[i]
                        break

            # Reverse head[i + 1:] and swap it with tail[:r - (i + 1)]
            tail += head[: i - self.in_number_of_selection : -1]  # head[i + 1:][::-1]
            i += 1
            head[i:], tail[:] = (
                tail[: self.in_number_of_selection - i],
                tail[self.in_number_of_selection - i :],
            )
            break
        return head

    def __yield_permutations(self):
        # Split A into the first r items and the last r items
        head, tail = (
            self.element_list[: self.in_number_of_selection],
            self.element_list[self.in_number_of_selection :],
        )
        right_head_indexes = range(self.in_number_of_selection - 1, -1, -1)
        left_tail_indexes = range(len(tail))

        while True:
            # print("more = ", head, tail)
            yield tuple(head)

            # Starting from the right, find the first index of the head with
            # value smaller than the maximum value of the tail - call it i.
            pivot = tail[-1]
            for i in range(self.in_number_of_selection - 1, -1, -1):
                if head[i] < pivot:
                    break
                pivot = head[i]
            else:
                return
            # Starting from the left, find the first value of the tail
            # with a value greater than head[i] and swap.
            for j in left_tail_indexes:
                if tail[j] > head[i]:
                    head[i], tail[j] = tail[j], head[i]
                    break
            # If we didn't find one, start from the right and find the first
            # index of the head with a value greater than head[i] and swap.
            else:
                for j in right_head_indexes:
                    if head[j] > head[i]:
                        head[i], head[j] = head[j], head[i]
                        break

            # Reverse head[i + 1:] and swap it with tail[:r - (i + 1)]
            tail += head[: i - self.in_number_of_selection : -1]  # head[i + 1:][::-1]
            i += 1
            head[i:], tail[:] = (
                tail[: self.in_number_of_selection - i],
                tail[self.in_number_of_selection - i :],
            )

    def all_case_new(self):
        result_list = []

        cal = self.__yield_permutations()
        current_permutation = self.element_list[: self.in_number_of_selection]
        result_list.append(current_permutation.copy())
        result_list.append(current_permutation)
        for i in range(1, self.max_possible - 1):

            current_permutation = self.__next_permutation_partial(
                current_permutation
            ).copy()
            result_list.append(current_permutation)
            next(cal)
            # print("----------------------")
        # while True:
        #     try:
        #         result_list.append(next(cal))
        #     except:
        #         break

        return result_list

    def all_case(self) -> list:
        """
        Return all possible permutations from a set parameters.

        Returns:
            list: All possible permutations.
        """
        if not self.element_list_initialized:
            raise Exception("element_list is not initialized")
        if not self.number_of_selection_initialized:
            raise Exception("number_of_selection is not initialized")

        result_list = []

        for i in range(self.max_possible):
            result_list.append(self.__permutation_core(i))
        return result_list

    def random_case(self, return_i=False) -> list:
        """
        Return a random possible permutation.

        Args:
            return_i (bool, optional): Return the iterator number indicating n-th permutation. Defaults to False.

        Returns:
            int (optional): The iterator number indicating n-th permutation. (return_i=True
            list: A random possible permutation.
        """

        if not self.element_list_initialized:
            raise Exception("element_list is not initialized")
        if not self.number_of_selection_initialized:
            raise Exception("number_of_selection is not initialized")

        random_i = (int)(random.random() * self.max_possible)

        if return_i:
            return random_i, self.__permutation_core(random_i)
        return self.__permutation_core(random_i)

    def n_th_case(self, in_iterator: int) -> list:
        """
        Return the n-th permutation.

        Args:
            in_iterator (int): The iterator that indicates the n-th permutation.

        Returns:
            list: The n-th permutation.
        """
        if not self.element_list_initialized:
            raise Exception("element_list is not initialized")
        if not self.number_of_selection_initialized:
            raise Exception("number_of_selection is not initialized")

        return self.__permutation_core(in_iterator)

    def n_to_m_th_case(self, in_n_iterator: int, in_m_iterator: int) -> list:
        """
        Return the n-th to m-th permutations.

        Args:
            in_n_iterator (int): The iterator that indicates the n-th permutation.
            in_m_iterator (int): The iterator that indicates the m-th permutation.

        Returns:
            list: The n-th to m-th permutations.
        """
        if not self.element_list_initialized:
            raise Exception("element_list is not initialized")
        if not self.number_of_selection_initialized:
            raise Exception("number_of_selection is not initialized")

        result_list = []
        for i in range(in_n_iterator, in_m_iterator + 1):
            result_list.append(self.__permutation_core(i))
        return result_list

    def __permutation_recursive(
        self, in_iterator: int, in_list: list, in_number_of_select: int
    ):
        result_list = []
        if in_number_of_select == 1:
            filtered_list = []
            # print("in 0 -> ", in_list, in_iterator)
            for i, data in enumerate(in_list):
                if data != 0:
                    filtered_list.append(i)
            result_list.append(filtered_list[in_iterator])
            # print("in 1 -> ", filtered_list, result_list)
            return result_list
        if in_number_of_select == 0:
            return result_list
        # results = list(filter(lambda x: x.startswith('f'), animals))

        for i in range(len(in_list)):
            if in_list[i] != 0:
                test_list = in_list[:i] + [in_list[i] - 1] + in_list[i + 1 :]
                test_list_possible_cases = self.__duplicated_case_recursive(
                    test_list, in_number_of_select - 1
                )
                if test_list_possible_cases > in_iterator:
                    result_list.append(i)
                    result_list += self.__permutation_recursive(
                        in_iterator,
                        test_list,
                        in_number_of_select - 1,
                    )

                    break
                else:
                    in_iterator -= test_list_possible_cases

        return result_list

    def __permutation_core(self, in_iterator: int):
        if not in_iterator < self.max_possible:
            return []

        bin_list, element_list = in_list_to_bin(self.element_list)

        result_iterator = self.__permutation_recursive(
            in_iterator, bin_list, self.in_number_of_selection
        )

        result_list = []
        for i in result_iterator:
            result_list.append(element_list[i])

        return result_list
